
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////
////    VERTEX SHADER : STOLEN FROM NEIGHBOURING SHADERS
////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

struct input
{
   float2 video_size;
   float2 texture_size;
   float2 output_size;
};

void main_vertex
(
   float4 position	: POSITION,
   out float4 oPosition : POSITION,
   uniform float4x4 modelViewProj,

   float2 tex : TEXCOORD,

   uniform input IN,
   out float2 oTexcoord : TEXCOORD,
   out float2 oFakeResolution : TEXCOORD1
)
{
   oPosition = mul(modelViewProj, position);
	oTexcoord = tex;
	oFakeResolution = IN.texture_size;
}


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////    EFFECT CONSTANTS : TWEAK THEM!
////

		// Size of the border effect
		static const float2 OverscanMaskHardness = {24.0f ,24.0f };
		// Attenuation of the border effect
		static const float OverscanMaskPower = 2.0f;
		// Intensity of the TV Corners (round-ness) deformation 
		static const float TVDeformInstensity = 0.08f;
		// How much R, G and B are offset : default is -0.333 pixels in fake-pixel-space
		static const float ColorFringeIntensity = -0.33333f;
		// How much luminosity is output by a fake-pixel
		static const float FakePixelMaskGain = 1.05f;
		// How much luminosity is output between fake-pixels (adds to the fake-pixel value)
		static const float FakePixelMaskOffset = 0.5f;
		// How sharp will appear the pixels (Horizontal Sharpness, Vertical Sharpness A.K.A Scanlines)
		static const float2 FakePixelMaskPower = {0.50f ,2.0f };
		// How much the Fake-Pixel effect is Active (0.0 = normal image, 1.0 = full FakePixel Effect)
		static const float FakePixelEffectBlend =0.75f ;

		// Ghost Sampling : enable define to activate
		#define GHOST_SAMPLING;
			static const float GhostLatencyIntensity = 0.30f;
			// Number of samples (higer is slower)
			static const int NumSamples = 8;
			// Latency of the RGB Signal (per-signal, in screen width percentage)
			static const float3 SignalLatencRGB = {0.037f,0.031f,0.025f};
			// Attenuation of the ghosting latency
			static const float SignalLatencyAttenuation = 3.0f;

////
////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

float expow(float value, float exponent) {
	return lerp(1.0f,pow(value,max(exponent,1.0f)),saturate(exponent));
}

// MultiSampling for ghosting effect
float3 GhostSample(sampler2D s, float2 t, float latency) {

	float3 Out = tex2D(s,t);
	float Weight = 1.0f;
	float2 Direction = float2(-latency,0.0f);
	for(int i=1; i < NumSamples; i++) {
		float curweight = pow(1.0f-((float)i/NumSamples),1.0f/SignalLatencyAttenuation);

		Out += GhostLatencyIntensity * curweight * tex2D(s,saturate(t+(1.0f-curweight)*Direction)).xyz;
		Weight += GhostLatencyIntensity * curweight;
	}
	return Out/Weight;
}



// Compositing of the TV Emulation
float3 TVEffect(float2 in_Position, float2 FakeResolution, sampler2D Texture) {

	// TV Deformation
	float2 ScreenPos = in_Position + dot(in_Position-0.5f,in_Position-0.5f)*(in_Position-0.5f)* TVDeformInstensity;
	
	// Sampling 3 Images biased to simulate TV RGB Offset

	#ifdef GHOST_SAMPLING 
		float3 SMP_Red = GhostSample(Texture, (ScreenPos),SignalLatencRGB.x).xyz;
		float3 SMP_Green = GhostSample(Texture, (ScreenPos) + ((float2(ColorFringeIntensity,0.0f))/FakeResolution),SignalLatencRGB.y).xyz;
		float3 SMP_Blue = GhostSample(Texture, (ScreenPos) + ((float2(ColorFringeIntensity*2.0f,0.0f))/FakeResolution),SignalLatencRGB.z).xyz;
	#else
		float3 SMP_Red = tex2D(Texture, (ScreenPos)).xyz;
		float3 SMP_Green = tex2D(Texture, (ScreenPos) + ((float2(ColorFringeIntensity,0.0f))/FakeResolution)).xyz;
		float3 SMP_Blue = tex2D(Texture, (ScreenPos) + ((float2(ColorFringeIntensity*2.0f,0.0f))/FakeResolution)).xyz;
	#endif
	// Overscan Darkening Mask
	float2 ScreenMask = pow(saturate(ScreenPos*(1.0f-ScreenPos)*OverscanMaskHardness),1.0f/OverscanMaskPower);
	// CRT Cell Masks (HorizontalRGB+Scanline)
	float PixelMaskR = expow(saturate(4*frac(ScreenPos.x*FakeResolution.x)*(1.0f-frac(ScreenPos.x*FakeResolution.x))),FakePixelMaskPower.x);
	float PixelMaskG = expow(saturate(4*frac(ScreenPos.x*FakeResolution.x+float2(ColorFringeIntensity,0.0f))*(1.0f-frac(ScreenPos.x*FakeResolution.x+float2(ColorFringeIntensity,0.0f)))),FakePixelMaskPower.x);
	float PixelMaskB = expow(saturate(4*frac(ScreenPos.x*FakeResolution.x+float2(ColorFringeIntensity*2.0f,0.0f))*(1.0f-frac(ScreenPos.x*FakeResolution.x+float2(ColorFringeIntensity*2.0f,0.0f)))),FakePixelMaskPower.x);
	float PixelMaskScanline = pow(saturate(4*frac(ScreenPos.y*FakeResolution.y)*(1.0f-frac(ScreenPos.y*FakeResolution.y))),FakePixelMaskPower.y);

	float3 PixelRGB = float3 ( 
								((PixelMaskR*PixelMaskScanline * FakePixelMaskGain)+FakePixelMaskOffset)  * SMP_Red.x ,
								((PixelMaskG*PixelMaskScanline * FakePixelMaskGain)+FakePixelMaskOffset)  * SMP_Green.y ,
								((PixelMaskB*PixelMaskScanline * FakePixelMaskGain)+FakePixelMaskOffset)  * SMP_Blue.z
								);
	
	// Non-Pixelated Image
	float3 ImageRGB = tex2D(Texture, ScreenPos).xyz;
	
	return lerp(ImageRGB, PixelRGB, FakePixelEffectBlend) * ScreenMask.x * ScreenMask.y;
	//return float3(PixelMaskR*PixelMaskScanline,PixelMaskG*PixelMaskScanline,PixelMaskB*PixelMaskScanline);
}

float4 main_fragment (in float2 TexCoord : TEXCOORD, in float2 FakeResolution : TEXCOORD1 , in float2 wpos : WPOS, uniform sampler2D s_p : TEXUNIT0) : COLOR
{
    vec4 color = vec4(1.0f,1.0f,1.0f,1.0f);
    color.xyz = TVEffect(TexCoord,FakeResolution, s_p );
    //color.xyz = float3(TexCoord.x,TexCoord.y, 0.0f );
	return color;
}
